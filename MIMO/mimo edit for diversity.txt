rng(1);
% randomness generator (to get fixed random set of bits every timie, so we can fairly compare performance every run)
%====================================================================
% Assuming we have Bandwidth of 25 MHz
% and subcarrier spacing (delta f) of 30 kHz.

   % Number of subcarriers= 833.33. It is rounded to 840 (multiple of 12)
   %In 4G/5G: 1 RB (Resource Block) = 12 consecutive subcarriers per slot in time
   % 840(70 RBs x 12)

      %FFT size is set to be the nearest power of two(2^x) next to Number of subcarriers
      %let FFT size (NFFT) be 2^10 = 1024
      %sampling frequenccy fs= NFFT * delta f = 30.72 MHz
      %cyclic prefix length = cyclic prefix time/ sampling time
      % = 2.38us * fs =~ 73
DeltaF = 30e3;           
Nsc    = 840;             
NFFT   = 1024;            
cpLen  = 73;              
fs     = NFFT * DeltaF;   
%=====================================================================


% MIMO 2x2
N_tx = 2;
N_rx = 2;

totalBits = 1e5;
SNRdB = 0:5:20; 
modSchemes = {'BPSK'};%,'QPSK', '8-PSK','ASK','FSK','8-PSK','16QAM'};

figure; hold on; grid on;

for mIdx = 1:length(modSchemes)
    modType = modSchemes{mIdx};

    switch modType
        case 'BPSK'
            M = 1; bitsPerSymbol = 1;
        case 'QPSK'
            M = 2; bitsPerSymbol = 2;
        case 'ASK'
            M = 4; bitsPerSymbol = 2;
        case 'FSK'
            M = 4; bitsPerSymbol = 2;
        case '8-PSK'
            M = 8; bitsPerSymbol = 3;
        case '16QAM'
            M = 16; bitsPerSymbol = 4;
    end

    %numOFDMSymbols = floor(totalBits/(Nsc * bitsPerSymbol * N_tx));
    numOFDMSymbolsDIV = floor(totalBits/(Nsc * bitsPerSymbol));
    %dataLen = numOFDMSymbolsDIV * Nsc * bitsPerSymbol * N_tx;
    dataLenDIV = numOFDMSymbolsDIV * Nsc * bitsPerSymbol;
    data = randi([0 1], dataLenDIV, 1);
    BERDIV = zeros(length(SNRdB),1);

    %data_reshaped = reshape(data, N_tx, []);
    
    for idx = 1:length(SNRdB)
         
        nErrors_total = 0;
        bits_processed = 0;
        
        % Transmitted symbols in OFDM grid for each TxAntenna N_tx(3d matrix)
        txSymb_grid = zeros(Nsc, numOFDMSymbolsDIV, N_tx);
        
        % Modulator - working on each transmit-antenna stream
        for working_tx_antenna = 1:N_tx
            txMod = ofdmModulator(data, modType); %serial
            txModParallel = reshape(txMod, Nsc, numOFDMSymbolsDIV) ; % serial to parallel
            
            % Store in txSymb_grid with antenna as third dimension
            txSymb_grid(:, :, working_tx_antenna) = txModParallel /sqrt(2);
        end
        
        % Process each OFDM symbol
        for symb_idx = 1:numOFDMSymbolsDIV
            
            %% =====================
            %% Channel Effect in frequency domain
            %% =====================
            
            % Generating frequency-domain Rayleigh channel for each subcarrier
            H_freq = (1/sqrt(2)) *(randn(N_rx, N_tx, Nsc) + 1i * randn(N_rx, N_tx, Nsc));
            
            
            rx_symbols_allSCs = zeros(N_rx, Nsc);
            
            for sc = 1:Nsc
                
                % working on channel effect on each subcarrier
                H_sc = H_freq(:, :, sc);

                %----------------------------------------------
                % Extract symbols from all antennas for this subcarrier and ofdm symbol
                %----------------------------------------------
                % Extracting the two symbols located at txModParallel(subcarrier index, ofdm symbol index)
                % but for both tranmitters
                tx_symbols_SC = txSymb_grid(sc, symb_idx, :);  
                % convert 3d to 2d column vector to process these two symbols                                             
                tx_symbols_SC = reshape(tx_symbols_SC, N_tx, 1); 
                
                %----------------------------------------------
                % ====
                 % Applying channel effect
                % ====
                % received symbols after applying channel effect
                rx_symbols_allSCs(:, sc) = H_sc * tx_symbols_SC;
            end
            
            %% =====================
            %% Add Noise in freuency domain
            %% =====================
            
            SNRlin = 10^(SNRdB(idx)/10);
            
            sig_power = mean(mean(abs(rx_symbols_allSCs).^2));
            perBitPower = sig_power / (bitsPerSymbol);           
            noise_power = perBitPower / SNRlin;
            
            % AWGN noise in frequency domain
            noise = sqrt(noise_power/2)*  (randn(size(rx_symbols_allSCs)) + ...
                                         1i * randn(size(rx_symbols_allSCs)));
            rx_symbols_noisy_withFading = rx_symbols_allSCs + noise;
            
%% =====================
%% MRC Combining
%% =====================

rxSymb_equalized = zeros(1, Nsc);

for sc = 1:Nsc
    H_sc = H_freq(:, :, sc);           
    y_sc = rx_symbols_noisy_withFading(:, sc);  

    % Received signals
    y1 = y_sc(1);
    y2 = y_sc(2);

    % channel coefficients
    h11 = H_sc(1,1);  % from Tx1 to Rx1
    h21 = H_sc(2,1);  % Tx1 to Rx2

    h12 = H_sc(1,2);  % Tx2 to Rx1  
    h22 = H_sc(2,2);  % Tx2 to Rx2


    
    g1 = h11 + h12;   % effective channel seen by Rx1
    g2 = h21 + h22;   % effective channel seen by Rx2

    % MRC
    numerator   = conj(g1)*y1 + conj(g2)*y2;
    denominator = abs(g1)^2 + abs(g2)^2;

    rxSymb_equalized(sc) = (numerator / denominator);
    
end

%% =====================
%% Demodulation
%% =====================

rxSymb = rxSymb_equalized;
rxDemod = ofdmDemodulator(rxSymb, modType);
rxBits = rxDemod(:);

OriginalDataSlices = data((symb_idx-1)*Nsc*bitsPerSymbol + 1 : symb_idx*Nsc*bitsPerSymbol);

[nErrors, ~] = biterr(OriginalDataSlices(:), rxBits);
nErrors_total = nErrors_total + nErrors;
bits_processed = bits_processed + length(OriginalDataSlices);

        end
        BERDIV(idx) = nErrors_total / bits_processed;
          
        fprintf('SNR = %d dB for %s... BER = %e\n', SNRdB(idx), modType, BERDIV(idx));

    end
    
    colors = lines(length(modSchemes));

    semilogy(SNRdB, BERDIV, 'LineWidth', 2, ...
             'Color', colors(mIdx,:), ...
             'DisplayName', [modType ' 2x2 MIMO']);
end

set(gca, 'YScale', 'log');
xlabel('SNR (dB)');
ylabel('Bit Error Rate');
title('2x2 MIMO');
legend('show', 'Location', 'southwest');
ylim([1e-5, 1]);
grid on;